好的，分析了您提供的代码后，我发现了一些可以改进的耦合点。遵循您“由点及面”的思路，我将从最具体、最容易修改的问题开始，逐步扩展到影响面更广的架构性问题。

以下是用表格形式对这些耦合点的分析说明：

### 代码耦合点分析与重构建议

| 不当耦合点 (Improper Coupling Point) | 应该分离的层/关注点 (Layer/Concern to Separate) | 涉及文件 (Involved Files) | 修改难度 (Difficulty) | 性价比 (Cost-Effectiveness) | 建议修改方案 (Suggested Refactoring) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **1. UI组件直接调用数据层方法**\<br\>UI组件（如`BlockView`, `TableView`）直接依赖并调用`DataStore`的**单例**方法来修改数据，例如 `DataStore.instance.markItemDone()`。 | **视图层 (View) 与 数据服务层 (Data Service)** | • `BlockView.tsx`\<br\>• `TableView.tsx`\<br\>• `dataStore.ts` | **低** | **高** | 在 `LayoutRenderer` 中定义 `onMarkItemDone` 函数，并通过 props 将其传递给 `BlockView` 和 `TableView`。这样，UI组件只负责调用传入的函数，而不知道具体是哪个Store在执行操作，便于未来替换或测试。 |
| **2. 服务层直接实例化UI组件**\<br\>`ActionService`在其方法中直接`new QuickInputModal(...)`，强耦合了核心服务逻辑与具体的UI弹窗实现。 | **核心服务层 (Core Service) 与 UI/特性层 (UI/Feature)** | • `ActionService.ts`\<br\>• `QuickInputModal.tsx` | **中** | **中** | `ActionService`的方法不应返回UI实例。它可以返回一个Promise或触发一个全局事件。由调用方（通常是UI层，如`LayoutRenderer`）来决定如何响应，例如打开哪个Modal。这样服务层就不再关心UI的具体实现。 |
| **3. 服务层之间互相直接依赖和实例化**\<br\>• `TimerService` 内部直接创建 `new InputService(app)`。\<br\>• `ActionService`, `TaskService`, `TimerService` 都直接访问 `DataStore.instance` 和 `AppStore.instance` 全局单例。 | **服务层内部解耦** | • `ActionService.ts`\<br\>• `TimerService.ts`\<br\>• `TaskService.ts`\<br\>• `dataStore.ts`\<br\>• `AppStore.ts` | **中** | **高** | **依赖注入 (Dependency Injection)**：在`main.ts`中统一创建所有服务实例。然后通过**构造函数**将一个服务所需的其他服务实例传递进去，而不是在服务内部创建或访问全局单例。这能清晰地展示服务间的依赖关系，并极大地简化测试。 |
| **4. "上帝对象" `ThinkPlugin` 实例被到处传递**\<br\>主插件实例 `this` (实现了 `ThinkContext` 接口) 被完整地传递给多个服务和功能模块的 `setup` 函数。 | **插件生命周期 与 核心业务逻辑** | • `main.ts`\<br\>• `RendererService.ts`\<br\>• `FloatingTimerWidget.ts`\<br\>• `dashboard/index.ts`\<br\>• `quick-input/index.ts` | **中** | **高** | **按需传递依赖**：不要传递整个 `plugin` 或 `ThinkContext` 对象。哪个模块需要什么，就只给它传递什么。例如，`RendererService` 的构造函数可以改为 `constructor(app, dataStore, appStore)`，而不是 `constructor(plugin, ...)`。 |
| **5. UI渲染组件中包含大量业务逻辑**\<br\>`LayoutRenderer.tsx` 中包含了大量关于数据筛选、排序和日期范围计算的逻辑 (`useMemo` 块中)。 | **视图渲染 (Rendering) 与 数据处理 (Data Processing)** | • `LayoutRenderer.tsx`\<br\>• `itemFilter.ts` | **中** | **高** | **创建自定义Hook**：将数据处理逻辑封装到一个自定义Hook中，例如 `useViewData(viewInstance, layoutDate, layoutView, kw)`。`LayoutRenderer` 只需调用这个Hook获取最终要渲染的数据 `viewItems` 即可。这让组件本身更专注于UI渲染，逻辑更清晰。 |
| **6. 贯穿整个应用的全局单例模式**\<br\>大量使用 `DataStore.instance` 和 `AppStore.instance`，导致任何模块都可以随意访问和修改全局状态。这是之前您修改 `store` 崩溃的**根本原因**。 | **全局状态管理 与 模块化** | 几乎所有文件 | **高** | **极高** | 这是最核心的重构点。目标是**消除所有 `.instance` 调用**。全面采用**依赖注入**（见第3点），将 `DataStore` 和 `AppStore` 的实例从顶层(`main.ts`)注入到需要它们的模块中。这是一个大手术，但能从根本上解决“牵一发而动全身”的问题。 |

-----

### 从“点”到“面”的重构策略

根据您的要求，我们可以按以下顺序进行，风险和影响范围从小到大：

1.  **第一步 (点)：清理UI层**

      * **目标**：先拿`BlockView`开刀，修改**耦合点 \#1**。
      * **操作**：在 `LayoutRenderer.tsx` 中创建 `handleMarkDone` 函数，把它作为prop传给 `BlockView`。`BlockView` 内部再传给 `TaskItem`，最终 `TaskCheckbox` 调用这个prop函数。
      * **影响**：只会影响 `LayoutRenderer`, `BlockView`, `TaskItem` 这几个文件，逻辑清晰，风险极低。成功后，可用同样方法改造 `TableView`。

2.  **第二步 (线)：清理服务层**

      * **目标**：解决**耦合点 \#2、\#3**。
      * **操作**：
          * 从 `TimerService` 中移除 `new InputService()`。在 `main.ts` 中创建 `inputService`，并将其作为参数传给需要它的 `TimerService` 方法。
          * 改造 `ActionService`，让它的构造函数接收 `appStore` 和 `dataStore` 作为参数：`constructor(app, appStore, dataStore)`。在 `main.ts` 中创建实例时把它们传进去。
      * **影响**：开始触及服务层，但改动是局部的。比如改造 `ActionService` 只需修改 `main.ts` 和 `ActionService.ts` 两个文件。

3.  **第三步 (面)：重构核心架构**

      * **目标**：解决**耦合点 \#4、\#5、\#6**。
      * **操作**：
          * **梳理依赖**：列出每个服务和UI组件到底需要哪些具体的依赖（`app`, `dataStore`, `appStore`等）。
          * **重构 `main.ts`**：在这里作为“装配中心”，创建所有服务实例，并手动处理它们之间的依赖关系。
          * **移除 `ThinkContext` 和 `this` 传递**：修改所有接收 `plugin` 或 `ctx` 的地方，改为接收具体的服务实例。
          * **移除所有 `.instance`**：这是最后一步，也是最关键的一步。全局搜索 `DataStore.instance` 和 `AppStore.instance`，将它们替换为通过构造函数或props传入的实例。
      * **影响**：这是全局性的重构，涉及面广，需要小心进行，但完成后代码的健壮性和可维护性会得到质的飞跃。

通过这种循序渐进的方式，您可以逐步改善代码质量，同时将每次修改的风险控制在可预见的范围内。