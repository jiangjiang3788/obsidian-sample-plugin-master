|优先级|重构建议|性价比 (回报/投入)|难度|涉及文件 (主要)|修改思路与详解|
|---|---|---|---|---|---|
|**1**|**引入依赖注入 (DI) 容器**|**极高**|中等|• `src/main.ts`<br>• `src/core/services/*`<br>• `src/features/*/index.ts`|**思路**: <br>1. 选择一个轻量级的DI库，例如 `tsyringe` 或 `typedi`。<br>2. 使用 `@injectable()` 或 `@Service()` 装饰器标记所有 `Service` 类。<br>3. 在 `main.ts` 中，不再手动 `new` 服务，而是从DI容器中 `resolve` (解析) 出顶层服务 (如 `RendererService`, `DataStore` 等)。<br>4. 服务之间的依赖关系通过构造函数参数类型自动注入。这彻底解耦了服务的创建和使用，是架构标准化的核心。<br><br>**示例 (使用 tsyringe):**<br>`typescript<br>// In a service file<br>import { injectable, inject } from "tsyringe";<br><br>@injectable()<br>export class RendererService {<br> constructor(<br> private dataStore: DataStore,<br> private appStore: AppStore<br> // ... other services<br> ) {}<br>}<br><br>// In main.ts<br>import "reflect-metadata";<br>import { container } from "tsyringe";<br><br>async onload() {<br> //...<br> // 注册实例 (如 plugin, app)<br> container.registerInstance(ThinkPlugin, this);<br> //...<br> // 解析顶层服务<br> this.dataStore = container.resolve(DataStore);<br> this.rendererService = container.resolve(RendererService);<br> // ...<br>}<br>`|
|**2**|**强化领域模型 (Domain) 的唯一真源**|**高**|低|• `src/core/domain/*`<br>• `src/features/dashboard/styles/global.ts`|**思路**:<br>1. **文件合并**: 将 `categoryColorMap.ts` 的内容合并到 `fields.ts` 或一个新建的 `definitions.ts` 中。颜色本身是字段的一种元数据。<br>2. **常量聚合**: 将 `constants.ts` 中与领域模型强相关的常量（如 `BLOCK_NAMES`, `FIELD_KEYS`）移入 `fields.ts` 或 `schema.ts`，让它们和定义在一起。UI相关的常量（如 `LOCAL_STORAGE_KEYS`）可以保留。<br>3. **CSS源**: 将 `GLOBAL_CSS` 从 `constants.ts` 移动到其所属的 `dashboard` feature 目录下的 `styles` 子目录中 (你已经这样做了，非常好！)。<br>4. **创建 Barrel File**: 在 `src/core/domain/index.ts` 中导出该目录下所有模块，使得其他地方可以用 `import { ... } from '@core/domain'` 统一导入。|
|**3**|**服务层职责再划分**|**中高**|中等|• `src/core/services/*`<br>• `src/platform/obsidian.ts`<br>• `src/main.ts`|**思路**:<br>1. **改造 `TaskService`**: `TaskService` 的职责应该是**唯一**修改 Markdown 文件中任务内容的服务。你已经将 `markItemDone` 的实现委托给了它，这是正确的方向。确保所有对任务行（如时间、时长修改）的操作都通过 `TaskService`。<br>2. **`DataStore` 纯粹化**: `DataStore` 的核心职责是 **读取和缓存** 数据，提供查询接口。它不应该直接修改文件。当文件变更时，它通过 `scanFile` 来更新自己的缓存。当前 `markItemDone` 的重构已经体现了这一点。<br>3. **`ActionService` 定位**: 将 `ActionService` 定位为一个“协调者”或“用例”层。它负责响应用户操作，从 `AppStore` 获取配置，调用 `TaskService` 或 `TimerService` 等执行具体操作，但它自己不实现核心业务逻辑。<br>4. **消除静态方法/单例依赖**: 将 `TaskService`, `TimerService`, `TimerStateService` 从包含静态方法的类改为需要实例化注入的普通类。这使得依赖关系更明确，也更易于测试。（你已完成此项，代码已体现）|
|**4**|**标准化 Feature 模块结构**|**中**|低|• `src/features/*`<br>• `src/main.ts`|**思路**:<br>1. **统一入口**: 确保每个 `feature` 目录（如 `dashboard`, `quick-input`）都有一个 `index.ts` 文件，并导出一个 `setup(deps)` 函数。这个函数接收所有该功能模块需要的依赖（服务、插件实例等）。<br>2. **内部结构**: 在每个 `feature` 目录内部，可以建立标准的子目录结构，例如：<br> - `ui/`: 存放所有UI组件 (React/Preact)。<br> - `logic/`: 存放该功能的逻辑，如命令注册 (`registerCommands.ts`)、事件监听器 (`VaultWatcher.ts`) 等。<br> - `styles/`: 存放该功能独有的CSS。<br>3. **依赖传递**: 在 `main.ts` 中，调用每个 `feature` 的 `setup` 函数，并通过DI容器传入所需的依赖，而不是手动传递一个巨大的 `context` 对象。|
|**5**|**统一`core`层出口**|**高**|**极低**|• `src/core/index.ts`<br>• (所有引用core内模块的文件)|**思路**:<br>1. 在你已经创建的 `src/core/index.ts` 文件中，全面导出 `services`, `domain`, `utils` 等所有核心层的公共模块。<br>2. 在 `tsconfig.json` 中配置路径别名，例如 `{"@core/*": ["src/core/*"]}`。<br>3. 在所有 `features` 和其他文件中，将复杂的相对路径导入改为统一的别名导入，如 `import { DataStore } from '@core/services'`。这极大提升了代码的可读性和可维护性。|
|**6**|**UI组件与状态解耦**|**中**|中高|• `src/features/*/ui/*`<br>• `src/state/AppStore.ts`|**思路 (长期优化)**:<br>1. **自定义Hooks**: 将复杂的UI逻辑（如 `useViewData`）抽取为自定义Hook，这使得组件本身更专注于渲染。你已经这么做了，非常棒。<br>2. **避免在组件中直接调用Store**: 在设置页面等地方，组件直接调用 `appStore.updateSomething()`。这在当前规模是可行的。对于更大型的项目，可以考虑引入类似 Redux 的 `dispatch(action)` 模式。`AppStore` 只暴露一个 `dispatch` 方法，所有修改操作都封装成 `Action` 对象，由 `AppStore` 内部的 `reducer` 处理。这会增加代码量，但能让状态变更的追溯和管理变得极为清晰。<br>**当前建议**: 保持现状，但在添加新功能时，优先考虑将复杂的状态逻辑封装在 `AppStore` 的方法中，而不是在UI组件中实现。|

### 建议的实施步骤 (渐进式)

1. **第1步 (简单整理 - 1小时)**:
    
    - 完成 **建议 #5 (统一`core`层出口)** 和 **建议 #2 (强化领域模型)**。这两项改动风险小，主要是文件移动和路径修改，能立刻提升代码整洁度。
        
2. **第2步 (核心改造 - 4-6小时)**:
    
    - 实施 **建议 #1 (引入DI容器)**。这是最核心的一步。一旦完成，整个项目的依赖关系将变得清晰无比，后续的重构会非常顺畅。你需要耐心修改所有服务的构造函数和 `main.ts` 的初始化逻辑。
        
3. **第3步 (逻辑优化 - 2-3小时)**:
    
    - 基于新的DI架构，审视并完成 **建议 #3 (服务层职责再划分)**。确保文件读写、状态管理、业务逻辑的边界清晰。
        
    - 同时完成 **建议 #4 (标准化Feature模块结构)**，让 `main.ts` 变得极其简洁，只负责组装和启动。
        
4. **第4步 (持续迭代)**:
    
    - 在未来的开发中，时刻谨记 **建议 #6 (UI与状态解耦)** 的原则，保持UI组件的纯粹性。