# 启动加速与查询优化实施方案

版本：v1.0  
日期：2025-10-20  
适用范围：Obsidian 插件（Think/样例插件代码库）

## 1. 背景与目标

- 现状：启动时对所有 Markdown 文件全量扫描与解析；UI 侧存在重复 filter/sort；查询在大数据量时速度下降。
- 目标：通过“持久化缓存 + 增量扫描”加速每次重新打开软件的冷启动，同时优化查询路径，降低交互延迟。

### 可量化指标（验收标准）

- 冷启动耗时：二次启动时显著低于全量扫描（以本地数据测量，目标降低 50%+）。
- 首屏可用时间：在缓存有效时，加载后 0.3–1s 内可见主要视图（视数据量而定）。
- 查询响应：常用筛选/排序（按日期/主题/标签）P95 < 200ms（以后端索引与缓存生效后）。

## 2. 总体思路

- 持久化缓存（cache.json）：按文件保存解析后的轻量条目与必要元信息（mtime/size），启动时先加载缓存复原内存，再仅对“有变更的文件”扫描。
- 增量扫描：监听 vault 的 create/modify/delete/rename 事件，按需更新单个文件对应的缓存与内存。
- 查询优化：预归一化字段（dateMs/titleLower/tagsLower…）+ 查询结果缓存；逐步引入内存索引（byTheme/byTag/byDateSorted）。
- 可选增强：持久化常用索引，启动即用；Web Worker 构建索引（数据量更大时考虑）。

## 3. 里程碑

- M1（阶段 0–3）：实现暖启动，二次启动不再全量读文件，首屏明显加速。
- M2（阶段 4–5）：预归一化字段与查询缓存、增量更新与防抖写入，交互更流畅。
- M3（阶段 6–7，可选）：持久化索引 + UI 调用迁移，稳定命中索引，延迟更低。
- 持续（阶段 8）：观测、回退与自愈。

## 4. 分阶段实施计划

### 阶段 0：建立性能基线（0.5 天）
- 任务
  - 在 `DataStore.initialScan/scanAll/scanFile` 前后埋点，记录启动总耗时、扫描总耗时、扫描文件数。
  - 首屏就绪埋点（Dashboard/LayoutRenderer 首次完成渲染时）。
  - 输出到 console 与 `performance-report.json`。
- 验收
  - 能稳定复现并输出三类基线数据，为后续对比提供依据。
- 清单
  - [ ] 启动埋点
  - [ ] 扫描埋点
  - [ ] 首屏就绪埋点

### 阶段 1：存储接口与注入（0.5 天）
- 任务
  - 新增 `IPluginStorage`（封装 Obsidian `loadData/saveData`）。
  - 通过 `tsyringe` 注入到 `DataStore`。
  - 验证能读写简单 JSON。
- 验收
  - 成功 `load/save { ping: "pong" }`，不影响现有功能。
- 清单
  - [ ] 定义接口/实现
  - [ ] 容器注册
  - [ ] 验证读写

### 阶段 2：定义缓存模型（0.5 天）
- 任务
  - 设计 Cache v1（轻量字段、按文件分片）。
- 结构（建议）
  - `schemaVersion: 1`
  - `files: Record<path, { mtime: number; size: number; items: CachedItem[] }>`
  - `CachedItem` 字段（按需裁剪）：
    - `id, filePath, filename`
    - `dateMs`
    - `categoryKey`
    - `themePathNormalized`
    - `titleLower?`, `contentLower?`
    - `tagsLower: string[]`
  - 预留：`indexes?: { byDateSorted?: Array<[dateMs, id]>; byTag?: Record<string, string[]>; byTheme?: Record<string, string[]> }`
- 验收
  - 类型定义完备，序列化/反序列化正确。
- 清单
  - [ ] 定义 `CacheV1`/`CachedItem`
  - [ ] 示例序列化/反序列化

### 阶段 3：DataStore 暖启动（1 天）
- 任务
  - `warmStart()` 流程：
    1) `loadData()` 取缓存；版本不符视为空。
    2) 列出所有 Markdown 文件（仅 stat: mtime/size）。
    3) 对比缓存：
       - 未变更：用缓存 items 直接复原 `this.items` 与 `fileIndex`。
       - 新增/变更：加入待扫描列表。
       - 已删除：从内存与缓存移除。
    4) 仅扫描变更文件；结束后合并内存并写回缓存（防抖）。
  - `initialScan()` 改为调用 `warmStart()`。
- 验收
  - 二次启动时，无需读取未变更文件内容，冷启动显著加速。
- 清单
  - [ ] `warmStart()` 实现
  - [ ] `initialScan()` 重定向
  - [ ] 缓存合并/写回

### 阶段 4：预归一化字段 + 查询缓存（0.5–1 天）
- 任务
  - 在 `scanFile` 生成 `Item` 时写入：
    - `dateMs`、`titleLower`、`contentLower`、`tagsLower`、`themePathNormalized`
  - `itemFilter` 使用上述字段（如 `filterByKeyword` 用 `titleLower`/`contentLower`）。
  - `DataStore` 查询缓存：
    - `key = hash({ filters, sortRules }) + dataVersion`
    - 数据变动后 `dataVersion++`（自动失效）。
- 验收
  - 热路径查询命中缓存；减少重复字符串处理/正则；查询延迟下降。
- 清单
  - [ ] 预处理字段落盘
  - [ ] 过滤/排序改读预处理字段
  - [ ] 查询缓存/失效

### 阶段 5：增量更新 + 防抖写入（0.5–1 天）
- 任务
  - 订阅 vault 事件：`create/modify/delete/rename`
    - `modify/create`：`scanFile(path)` 并更新 `cache.files[path]`
    - `delete`：`removeFileItems(path)` 并从缓存删除条目
    - `rename`：按 `delete+create` 处理（更稳妥）
  - 缓存写入防抖：1–3 秒合并写。
- 验收
  - 大量变更时主线程不卡顿；写缓存次数受控。
- 清单
  - [ ] 事件订阅
  - [ ] 批处理/队列
  - [ ] 防抖写入

### 阶段 6（可选）：持久化常用索引（1–2 天）
- 任务
  - 在缓存 `indexes` 中持久化：
    - `byDateSorted: Array<[dateMs, id]>`
    - Record<tagLower, string[]>`
    - `byTheme: Record<themePathNormalized, string[]>`
  - 启动时直接复原（或延迟构建 Map/Set）。
- 验收
  - 启动后索引即时可用；查询稳定低延迟。
- 清单
  - [ ] 序列化/反序列化索引
  - [ ] 更新路径联动
  - [ ] 启动复原

### 阶段 7：调用方迁移与体验优化（并行）
- 任务
  - 将 UI 中“全量取出再 filter/sort”的调用迁移为 `queryItems(filters, sortRules)` 或快捷查询：
    - `queryByDateRange(start,end)`、`queryByTheme(path)`、`queryByTags(tags, mode)`
  - 大列表虚拟化（如需要）：`react-window`/`preact-virtual-list`。
- 验收
  - 主要页面不再做重复 O(n) 遍历；交互延迟稳定。
- 清单
  - [ ] 高频页面迁移
  - [ ] 虚拟列表（如有大列表）

### 阶段 8：观测与回退（0.5 天）
- 任务
  - 设置开关：启用/禁用缓存、启用/禁用持久化索引、清空缓存。
  - 异常处理：`loadCache` 失败或版本不兼容时自动全量重建并提示一次。
  - 指标：缓存命中率、增量扫描文件数、平均扫描耗时、查询平均耗时。
- 验收
  - 用户可手动回退；异常情况下系统能自愈。
- 清单
  - [ ] 设置项
  - [ ] 指标输出
  - [ ] 清理/回退按钮

## 5. 缓存结构（示例）

```json
{
  "schemaVersion": 1,
  "files": {
    "Daily/2025-10-20.md": {
      "mtime": 1697777777000,
      "size": 12345,
      "items": [
        {
          "id": "Daily/2025-10-20.md#42",
          "filePath": "Daily/2025-10-20.md",
          "filename": "2025-10-20",
          "dateMs": 1697750400000,
          "categoryKey": "work/done",
          "themePathNormalized": "生活/学习",
          "titleLower": "修复数据查询性能",
          "contentLower": "…",
          "tagsLower": ["obsidian","perf"]
        }
      ]
    }
  },
  "indexes": {}
}
```

> 注意：仅保存查询热字段，避免缓存过大；原文内容按需懒加载。

## 6. DataStore 改造要点

- `warmStart()`：加载缓存 → 目录 stat → 仅扫描变更 → 合并内存 → 防抖保存。
- `scanFile()`：输出 `Item` 时补充 `dateMs/titleLower/tagsLower/themePathNormalized`。
- `queryItems()`：增加查询缓存（基于 `dataVersion` 失效）。
- 事件驱动：`create/modify/delete/rename` 触发增量更新。
- 版本迁移：`schemaVersion` 不兼容时自动全量重建一次。

## 7. 风险与回退

- 内存/体积增加：仅索引高频字段，限制 posting list；必要时分片 cache。
- 缓存损坏：try/catch 自愈，失败即全量重建；提供“清空缓存”按钮。
- 一致性：变更处理顺序“先移除旧→再新增”，在一次事务内完成，减少短暂不一致。
- 可配置：设置中提供开关，便于回退与问题定位。

## 8. 实施建议

- 先完成 M1（阶段 0–3），尽快得到冷启动收益。
- 结合真实数据量逐步引入索引（M2/M3）；以“可观测 + 回退”为保障。
- 迁移 UI 调用时优先高频页面，减少重复 filter/sort 的 O(n) 压力。

---

附：阶段执行清单（总览）
- [ ] 阶段 0 基线
- [ ] 阶段 1 存储接口
- [ ] 阶段 2 缓存模型
- [ ] 阶段 3 暖启动
- [ ] 阶段 4 预处理 + 查询缓存
- [ ] 阶段 5 增量 + 防抖
- [ ] 阶段 6 持久化索引（可选）
- [ ] 阶段 7 调用迁移/虚拟化
- [ ] 阶段 8 观测与回退
