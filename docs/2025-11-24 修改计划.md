

# AI 自然语言快捷输入实现计划

目标：  
在现有 Think 插件（Block + Theme + 字段配置 + 快速输入）的基础上，实现统一的「AI 自然语言 → 自动选择合适 Block/Theme → 自动填字段 → 显示确认 UI → 保存」能力，并提供 AI 设置页面控制行为与性能。
第一步：把 AI “接入设置与类型体系”，并在 UI 中可配置

产出：settings.aiSettings 正式存在；设置页出现 “AI” Tab；用户可配置 endpoint/model/key、启用哪些 blocks、多结果行为、缓存等。

1.1 新增 AI 类型文件并挂到 ThinkSettings

新增文件： src/core/types/ai-schema.ts

建议最终类型（比你原稿更贴合现有工程）：

export interface AiSettings {
  enabled: boolean;

  // OpenAI-compatible（你接 Gemini/自建转发都可）
  provider: 'openai_compat';
  apiEndpoint: string;  // baseURL，例如 https://xxx/v1
  apiKey: string;
  model: string;
  temperature: number;
  maxTokens: number;
  requestTimeoutMs: number;

  // block/theme 选择策略
  enabledBlockIds?: string[]; // 优先用它过滤 snapshot；为空=全部参与
  defaultThemeId?: string;

  // 多结果与确认策略
  allowMultipleResults: boolean;
  maxResults: number;
  confirmMode: 'single' | 'batch'; // 先实现 single + batch逐条确认（仍属于batch）

  // 性能
  preloadConfigOnStartup: boolean;
  configCacheTTLSeconds: number;
}

export interface NaturalRecordCommand {
  rawText: string;
  target: { blockId: string; themeId?: string };
  fieldValues: Record<string, any>; // 不要 string，兼容 select/rating 等
  meta?: { confidence?: number; reason?: string };
}

export interface NaturalRecordBatch {
  items: NaturalRecordCommand[];
}


修改文件： src/core/types/schema.ts

在 ThinkSettings 增加：aiSettings?: AiSettings

在 DEFAULT_SETTINGS 中追加默认值（沿用你现在“干净默认”风格）

你的持久化是直接存 settings；旧数据缺字段时靠 DEFAULT_SETTINGS 兜住即可。

1.2 设置页增加 AI Tab

修改文件： src/features/settings/SettingsTab.tsx

Tabs 增加 AI

Panel 增加 <AiSettings appStore={appStore} />

新增文件： src/features/settings/AiSettings.tsx

UI（最小可用版）：

开关：enabled

OpenAI-Compat 配置：apiEndpoint / apiKey / model / temperature / maxTokens / requestTimeoutMs

Block 参与范围：

从 settings.inputSettings.blocks 动态列出

用多选/checkbox 保存到 enabledBlockIds

提供按钮：“初始化为全部 block”

多结果：

allowMultipleResults / maxResults / confirmMode

性能：

preloadConfigOnStartup / configCacheTTLSeconds

写回方式：复用你现有的 appStore._updateSettingsAndPersist(draft => { ... })

1.3 抽取 getEffectiveTemplate 成通用工具

这是后面 AI Snapshot / 运行时合成 / Theme 可用性判断的统一锚点，避免规则分叉。

改造：

把 src/features/quickinput/QuickInputModal.tsx 中的 getEffectiveTemplate(...) 移到：

✅ 建议：src/core/utils/inputTemplateUtils.ts

QuickInputModal.tsx 改为 import 使用（确保行为不变）

可选再抽一个：

getAvailableThemesForBlock(settings, blockId)（若你 QuickInput 里已经有“override 禁用 theme”的逻辑，也一起抽出来，AI snapshot 会更准）

第二步：实现 AI 解析与命令闭环（复用 QuickInputModal 做确认 UI）

产出：新增一个命令 AI: 自然语言快速记录（统一）
流程：输入自然语言 → AI 返回一条/多条结构化命令 → 逐条打开 QuickInputModal 预填 → 用户确认保存 → executeTemplate 落盘。

2.1 新增 AI 配置快照 + 缓存

新增目录： src/core/ai/

新增文件： src/core/ai/AiConfigSnapshot.ts

快照只保留“给模型看的最小子集”，避免 prompt 过大：

export interface AiBlockConfig {
  id: string;
  name: string;
  fields: Array<{
    key: string;
    label: string;
    type: string;
    options?: Array<{ value: string; label: string }>;
    defaultValue?: any;
  }>;
}

export interface AiThemeConfig {
  id: string;
  path: string;
}

export interface AiConfigSnapshot {
  blocks: AiBlockConfig[];
  themes: AiThemeConfig[];
}


构建规则（结合你工程）：

blocks 来源：settings.inputSettings.blocks

fields：来自 effective template 的 fields（建议：对每个 block 用 getEffectiveTemplate(inputSettings, blockId, undefined) 取字段；如果你 fields 在 block 本身就已完整，也可直接用 block.fields）

themes：settings.inputSettings.themes

过滤 blocks：若 aiSettings.enabledBlockIds 有值 → 只保留这些

新增文件： src/core/ai/AiConfigCache.ts

TTL 缓存 snapshot

提供 invalidate()

在设置更新时是否强制 invalidate：先不做全局监听也行（MVP 下只靠 TTL + 重启即可）；你想严谨的话，再在 AppStore 更新 inputSettings 时调用 invalidate。

2.2 新增 OpenAI-Compatible HTTP Client（你后接 Gemini）

新增文件： src/core/ai/AiHttpClient.ts

实现要点：

POST {apiEndpoint}/chat/completions

headers：Authorization: Bearer ${apiKey}

body：{ model, temperature, max_tokens, messages }

timeout：用 AbortController 支持 requestTimeoutMs

输出：返回 assistant_message_content: string

2.3 实现 NaturalLanguageRecordParser（核心 Prompt + JSON 解析）

新增文件： src/core/ai/AiNaturalLanguageRecordParser.ts

接口：

export interface INaturalLanguageRecordParser {
  parse(input: { text: string; now: Date }): Promise<NaturalRecordBatch>;
}


Prompt 关键约束（贴合你的 QuickInputForm）：

fieldValues 的 key 必须是 TemplateField.key

date/time 格式：

date: YYYY-MM-DD

time: HH:mm

select/radio/rating：

优先输出 option.value；如果只能输出 label 也可（你后面可做一次 label→value 映射兜底）

输出必须是纯 JSON：NaturalRecordBatch

解析策略：

JSON.parse(raw)

失败则截取第一个 { 到最后一个 } 再 parse

仍失败 → 抛出可读错误（命令层弹 Notice + 提示用户重试/改写）

2.4 命令：AI 自然语言快速记录（统一）

新增 feature： src/features/aiinput/

src/features/aiinput/registerCommands.ts

src/features/aiinput/index.ts（导出 setup）

src/app/FeatureLoader.ts 中加载该 feature（仿 quickinput）

命令伪代码（MVP：单条/多条都“逐条确认”）：

callback: async () => {
  const s = appStore.getSettings();
  if (!s.aiSettings?.enabled) return Notice(...);

  // 1) 让用户输入自然语言
  const text = await promptModal(); // 你可以先做个简单 Modal

  // 2) parser.parse -> batch
  const batch = await parser.parse({ text, now: new Date() });

  // 3) 对每条结果：直接复用 QuickInputModal 做确认 UI
  //    关键：把 AI fieldValues 作为 context 传给 QuickInputModal
  for (const cmd of batch.items.slice(0, s.aiSettings.maxResults)) {
    new QuickInputModal(app, cmd.target.blockId, cmd.fieldValues, cmd.target.themeId).open();
    // 用户点保存 -> inputService.executeTemplate(...) 已执行
    // 用户取消 -> 不保存
  }
}


这一步几乎不需要写“确认 UI”新轮子，因为 QuickInputModal 本身已经是“确认+编辑+保存”。

2.5 第二步的“完成标准”（你可以按这个验收）

AI Tab 能配置并持久化（重启后仍存在）

命令能弹出输入框，输入一句自然语言

能自动选择 blockId/themeId（至少 block 选择准确）

QuickInputModal 打开时字段已预填（靠 context[key]）

用户点保存 → 文件写入与 Item 更新都正常（沿用 executeTemplate）

多条结果时：会依次弹出多个 QuickInputModal，用户可逐条取消/保存


第二步：实现 AI 解析与命令闭环（复用 QuickInputModal 做确认 UI）
目标与验收

目标：

新增命令：AI: 自然语言快速记录（统一）

用户输入自然语言 → AI 输出结构化 NaturalRecordBatch

对每条结果：new QuickInputModal(app, blockId, fieldValues, themeId).open()
让用户确认/编辑/保存（复用现有保存逻辑）

验收：

命令可用；2) AI 能返回 JSON 并成功 parse；3) QuickInputModal 预填生效；4) 保存落盘正常；5) 多条时逐条弹窗可取消/保存。

2.1 新增 src/core/ai/ 目录与快照缓存
TODO 2.1.1 新建 src/core/ai/AiConfigSnapshot.ts

**职责：**把 inputSettings + aiSettings(enabledBlockIds) 转成模型可读的最小快照。

// src/core/ai/AiConfigSnapshot.ts
import type { InputSettings, ThinkSettings } from "src/core/types/schema";
import type { AiSettings } from "src/core/types/ai-schema";
import { getEffectiveTemplate } from "src/core/utils/inputTemplateUtils";

export interface AiBlockConfigField {
  key: string;
  label: string;
  type: string;
  options?: Array<{ value: string; label: string }>;
  defaultValue?: any;
}

export interface AiBlockConfig {
  id: string;
  name: string;
  fields: AiBlockConfigField[];
}

export interface AiThemeConfig {
  id: string;
  path: string;
}

export interface AiConfigSnapshot {
  blocks: AiBlockConfig[];
  themes: AiThemeConfig[];
}

export function buildAiConfigSnapshot(input: InputSettings, ai: AiSettings): AiConfigSnapshot {
  const enabledSet = ai.enabledBlockIds?.length ? new Set(ai.enabledBlockIds) : null;

  const blocks = input.blocks
    .filter(b => !enabledSet || enabledSet.has(b.id))
    .map(b => {
      // 用你抽出来的 getEffectiveTemplate 来拿字段（最贴合实际 override）
      const effective = getEffectiveTemplate(input, b.id, undefined);
      const fields = (effective?.fields ?? b.fields ?? []).map(f => ({
        key: f.key,
        label: f.label,
        type: f.type,
        options: (f.options ?? []).map((o: any) => ({ value: o.value, label: o.label })),
        defaultValue: (f as any).defaultValue,
      }));
      return { id: b.id, name: b.name, fields };
    });

  const themes = input.themes.map(t => ({ id: t.id, path: t.path }));

  return { blocks, themes };
}


注：如果 getEffectiveTemplate 返回 null，fallback b.fields。

TODO 2.1.2 新建 src/core/ai/AiConfigCache.ts

**职责：**TTL 缓存 snapshot，避免每次调用模型都重新拼大段 prompt。

// src/core/ai/AiConfigCache.ts
import type { ISettingsProvider } from "src/core/services/settings/ISettingsProvider";
import { buildAiConfigSnapshot, type AiConfigSnapshot } from "./AiConfigSnapshot";

export class AiConfigCache {
  private snapshot: AiConfigSnapshot | null = null;
  private lastUpdated = 0;

  constructor(private settingsProvider: ISettingsProvider) {}

  getSnapshot(): AiConfigSnapshot {
    const settings = this.settingsProvider.getSettings();
    const ai = settings.aiSettings;
    if (!ai) throw new Error("AI settings missing");

    const ttlMs = (ai.configCacheTTLSeconds ?? 300) * 1000;
    const now = Date.now();

    if (!this.snapshot || now - this.lastUpdated > ttlMs) {
      this.snapshot = buildAiConfigSnapshot(settings.inputSettings, ai);
      this.lastUpdated = now;
    }
    return this.snapshot;
  }

  invalidate() {
    this.snapshot = null;
    this.lastUpdated = 0;
  }
}


MVP 可不做自动 invalidate，先靠 TTL。

2.2 新增 OpenAI-Compatible HTTP Client（你接 Gemini / 代理也 OK）
TODO 2.2.1 新建 src/core/ai/AiHttpClient.ts
// src/core/ai/AiHttpClient.ts
export type OpenAIChatMessage = { role: "system" | "user" | "assistant"; content: string };

export interface ChatCompletionRequest {
  baseURL: string;         // 例如 https://xxx/v1
  apiKey: string;
  model: string;
  temperature: number;
  max_tokens: number;
  messages: OpenAIChatMessage[];
  timeoutMs: number;
}

export class AiHttpClient {
  async chatCompletion(req: ChatCompletionRequest): Promise<string> {
    const url = req.baseURL.replace(/\/$/, "") + "/chat/completions";

    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), req.timeoutMs);

    try {
      const res = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${req.apiKey}`,
        },
        body: JSON.stringify({
          model: req.model,
          temperature: req.temperature,
          max_tokens: req.max_tokens,
          messages: req.messages,
        }),
        signal: controller.signal,
      });

      if (!res.ok) {
        const text = await res.text().catch(() => "");
        throw new Error(`AI HTTP ${res.status}: ${text}`);
      }

      const json = await res.json();
      const content = json?.choices?.[0]?.message?.content;
      if (!content) throw new Error("AI returned empty content");
      return content;
    } finally {
      clearTimeout(t);
    }
  }
}


如果你后面想更稳：可改成 Obsidian 的 requestUrl，但 MVP 用 fetch 就能跑。

2.3 实现解析器 AiNaturalLanguageRecordParser
TODO 2.3.1 新建 src/core/ai/AiNaturalLanguageRecordParser.ts
import type { INaturalLanguageRecordParser } from "./INaturalLanguageRecordParser";
import type { NaturalRecordBatch } from "src/core/types/ai-schema";
import type { ISettingsProvider } from "src/core/services/settings/ISettingsProvider";
import { AiConfigCache } from "./AiConfigCache";
import { AiHttpClient } from "./AiHttpClient";

function safeJsonParseBatch(raw: string): NaturalRecordBatch {
  try {
    return JSON.parse(raw);
  } catch {
    const start = raw.indexOf("{");
    const end = raw.lastIndexOf("}");
    if (start >= 0 && end > start) {
      const sliced = raw.slice(start, end + 1);
      return JSON.parse(sliced);
    }
    throw new Error("AI output is not valid JSON");
  }
}

export class AiNaturalLanguageRecordParser implements INaturalLanguageRecordParser {
  constructor(
    private settingsProvider: ISettingsProvider,
    private cache: AiConfigCache,
    private http: AiHttpClient
  ) {}

  async parse(input: { text: string; now: Date }): Promise<NaturalRecordBatch> {
    const settings = this.settingsProvider.getSettings();
    const ai = settings.aiSettings;
    if (!ai?.enabled) throw new Error("AI is disabled");

    const snapshot = this.cache.getSnapshot();
    const nowIso = input.now.toISOString();

    const system = [
      "You are a parser that converts natural language into Think plugin record commands.",
      "Return ONLY valid JSON. No markdown. No explanations.",
      "Output schema: { items: NaturalRecordCommand[] }",
      "NaturalRecordCommand:",
      "- target.blockId must match one of snapshot.blocks[].id",
      "- target.themeId must match snapshot.themes[].id or be omitted",
      "- fieldValues keys must be TemplateField.key (from snapshot.blocks[].fields[].key)",
      "- date fields: YYYY-MM-DD, time fields: HH:mm",
      "- select/radio/rating: prefer option.value; label is acceptable if unsure",
    ].join("\n");

    const user = [
      `Now: ${nowIso}`,
      `Max results: ${ai.allowMultipleResults ? ai.maxResults : 1}`,
      "Snapshot JSON:",
      JSON.stringify(snapshot),
      "User text:",
      input.text,
      "Return JSON now."
    ].join("\n\n");

    const raw = await this.http.chatCompletion({
      baseURL: ai.apiEndpoint,
      apiKey: ai.apiKey,
      model: ai.model,
      temperature: ai.temperature,
      max_tokens: ai.maxTokens,
      timeoutMs: ai.requestTimeoutMs ?? 20000,
      messages: [
        { role: "system", content: system },
        { role: "user", content: user },
      ],
    });

    const batch = safeJsonParseBatch(raw);

    // 兜底：若不允许多结果，截断为 1
    if (!ai.allowMultipleResults && batch.items.length > 1) {
      batch.items = batch.items.slice(0, 1);
    }
    // 兜底：maxResults
    if (ai.maxResults && batch.items.length > ai.maxResults) {
      batch.items = batch.items.slice(0, ai.maxResults);
    }
    return batch;
  }
}

TODO 2.3.2 新建接口文件 src/core/ai/INaturalLanguageRecordParser.ts
import type { NaturalRecordBatch } from "src/core/types/ai-schema";

export interface INaturalLanguageRecordParser {
  parse(input: { text: string; now: Date }): Promise<NaturalRecordBatch>;
}

2.4 DI 注册（让命令层能拿到 parser/cache/http）

你项目用 tsyringe，核心注册在 src/core/di/setupCore.ts（或类似）。

TODO 2.4.1 修改 src/core/di/setupCore.ts

注册（示意）：

import { AiConfigCache } from "src/core/ai/AiConfigCache";
import { AiHttpClient } from "src/core/ai/AiHttpClient";
import { AiNaturalLanguageRecordParser } from "src/core/ai/AiNaturalLanguageRecordParser";

container.registerSingleton(AiConfigCache);
container.registerSingleton(AiHttpClient);
container.registerSingleton(AiNaturalLanguageRecordParser);


settingsProvider 你已经通过 SettingsProviderToken -> AppStore 注册好了，AiConfigCache/AiParser 构造时会拿到。

2.5 新增命令 Feature（最小闭环）
TODO 2.5.1 新建 feature 目录

src/features/aiinput/index.ts

src/features/aiinput/registerCommands.ts

TODO 2.5.2 新建一个简单输入 Modal（MVP）

你可以先用 Obsidian 的 Modal，放一个 textarea：

新增文件： src/features/aiinput/AiTextPromptModal.ts

返回 Promise<string|null>。

（这里我不贴太长 UI 代码，你照 QuickInputModal 的写法即可：textarea + buttons）

TODO 2.5.3 实现 registerCommands（逐条弹 QuickInputModal）

文件： src/features/aiinput/registerCommands.ts

核心流程：

import { Notice } from "obsidian";
import { QuickInputModal } from "src/features/quickinput/QuickInputModal";
import { AiTextPromptModal } from "./AiTextPromptModal";
import { AiNaturalLanguageRecordParser } from "src/core/ai/AiNaturalLanguageRecordParser";

export function registerAiInputCommands(deps: {
  plugin: any;
  app: any;
  appStore: any;
  container: any; // 你项目里获取 container 的方式
}) {
  const { plugin, app, appStore, container } = deps;

  plugin.addCommand({
    id: "think-ai-natural-input",
    name: "AI: 自然语言快速记录（统一）",
    callback: async () => {
      const settings = appStore.getSettings();
      const ai = settings.aiSettings;
      if (!ai?.enabled) {
        new Notice("AI 快速记录未启用，请在设置中开启", 4000);
        return;
      }

      const text = await new AiTextPromptModal(app).openAndGetValue();
      if (!text?.trim()) return;

      const parser = container.resolve(AiNaturalLanguageRecordParser);

      let batch;
      try {
        batch = await parser.parse({ text, now: new Date() });
      } catch (e: any) {
        new Notice(`AI 解析失败：${e?.message ?? e}`, 6000);
        return;
      }

      if (!batch.items?.length) {
        new Notice("AI 未能识别出可记录内容，请换种说法再试", 5000);
        return;
      }

      // MVP：逐条确认 -> 复用 QuickInputModal
      for (const cmd of batch.items) {
        // QuickInputModal 已支持 context + themeId 预选（按你描述）
        new QuickInputModal(app, cmd.target.blockId, cmd.fieldValues, cmd.target.themeId).open();
      }
    },
  });
}

TODO 2.5.4 在 FeatureLoader 加载 AI feature

文件： src/app/FeatureLoader.ts

模仿 quickinput 的加载方式：

import aiinput/setup

在 loadFeatures() 中调用 loadAiInputFeature()

2.6 第二步的“已知限制（MVP 接受）”

多条确认：不是列表 UI，而是依次弹 QuickInputModal（最省工，且满足“写入前确认”）

若 AI 输出 select/radio 的 label 而不是 value：先接受（后续可加映射）

snapshot 体积：blocks/fields 多时 prompt 变大（先靠 enabledBlockIds + TTL）

2.7 第二步完成后的下一步（不在本次范围）

真正的 Batch 列表确认 UI（左列表右编辑）

label→value 映射、字段类型校验/修正

在 QuickInputModal 打开前做一次 themeId 合法性校验（不存在就 drop）

settings 变更时 cache.invalidate