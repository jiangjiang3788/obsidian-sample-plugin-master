好，我直接给你**可以照着一步步干的重构指令**，目标就是：

> 把「和数据、统计、配置相关的逻辑」搬到 `core`，
> 让 `features/views/*` 和 `features/settings/*ViewEditor.tsx` 只做 UI，
> 逻辑由 `core/config` + `core/utils` 统一提供，每个视图共用。

我分三块说：

1. 先拿 **Heatmap 视图** 做一个完整示范（包含默认配置 + 扫描主题逻辑）。
2. 然后是 **Statistics 视图** 的共用逻辑拆法。
3. 最后给你一份「**所有视图复用的通用操作清单**」，你可以按这个模版批量改 Table / Timeline / Excel / BlockView 等。

---

## 一、Heatmap 视图：逻辑拆到 core 的具体指令

### 步骤 1：把 Heatmap 的默认配置移到 `core/config/viewConfigs.ts`

1. 打开：`features/settings/HeatmapViewEditor.tsx`
   你现在有这段：

```ts
// 视图的默认配置
export const DEFAULT_CONFIG = {
    displayMode: 'habit', // 'habit' or 'count'
    sourceBlockId: '',
    themePaths: [] as string[],
    enableLeveling: true,
    maxDailyChecks: 10,
    allowManualEdit: true,
    showLevelProgress: true,
};
```

2. 把上面这一整段**剪切**，不要留在 Editor 里。

3. 打开：`core/config/viewConfigs.ts`，在文件末尾追加：

```ts
// HeatmapView 默认配置（供视图 + 编辑器复用）
export interface HeatmapViewConfig {
    displayMode: 'habit' | 'count';
    sourceBlockId: string;
    themePaths: string[];
    enableLeveling: boolean;
    maxDailyChecks: number;
    allowManualEdit: boolean;
    showLevelProgress: boolean;
}

export const HEATMAP_VIEW_DEFAULT_CONFIG: HeatmapViewConfig = {
    displayMode: 'habit',
    sourceBlockId: '',
    themePaths: [],
    enableLeveling: true,
    maxDailyChecks: 10,
    allowManualEdit: true,
    showLevelProgress: true,
};
```

4. 回到 `features/settings/HeatmapViewEditor.tsx`，顶部加上：

```ts
import { HEATMAP_VIEW_DEFAULT_CONFIG } from '@core/config/viewConfigs';
```

然后在组件里用：

```ts
const config = { ...HEATMAP_VIEW_DEFAULT_CONFIG, ...value };
```

5. **为了不破坏现有引用**（比如 `HeatmapView.tsx` 现在是从 Editor 里 import `DEFAULT_CONFIG`），在 `HeatmapViewEditor.tsx` 里加一行**重新导出**：

```ts
export { HEATMAP_VIEW_DEFAULT_CONFIG as DEFAULT_CONFIG } from '@core/config/viewConfigs';
```

> ✅ 这样做完之后：
>
> * 真正的默认配置只在 core 里定义一次。
> * 视图 / 编辑器都从 core 拿，做到“每个视图共用 core 配置”。

---

### 步骤 2：把「扫描 themePaths」的逻辑拆到 `core/utils/heatmap.ts`

现在 `HeatmapViewEditor.tsx` 里的扫描逻辑长这样（简化版）：

```ts
const handleScanThemes = () => {
    if (!module?.dataSourceId) { new Notice('...'); return; }
    if (!config.sourceBlockId) { new Notice('...'); return; }

    const dataSource = allDataSources.find(ds => ds.id === module.dataSourceId);
    if (!dataSource) { new Notice('...'); return; }

    const sourceBlock = allBlocks.find(b => b.id === config.sourceBlockId);
    if (!sourceBlock) { new Notice('...'); return; }

    const items = dataStore.queryItems();
    const filteredItems = filterByRules(items, dataSource.filters);

    const themeSet = new Set<string>();
    filteredItems.forEach(item => {
        if (item.categoryKey === sourceBlock.name && item.theme) {
            themeSet.add(item.theme);
        }
    });

    const sortedThemes = Array.from(themeSet).sort((a, b) => a.localeCompare(b, 'zh-CN'));
    onChange({ themePaths: sortedThemes });
    new Notice(`扫描完成！已自动添加 ...`);
};
```

**目标**：
把其中这部分“纯数据逻辑”抽到 core：

* 用 filters 过滤 items
* 从符合条件的 items 里提取 theme，并去重排序

#### 2.1 新建 core 工具文件

1. 创建新文件：`core/utils/heatmap.ts`
2. 填入：

```ts
// src/core/utils/heatmap.ts
import type { Item, ViewInstance, BlockTemplate } from '@/core/types/schema';
import { filterByRules } from './itemFilter';

/**
 * 从数据源中过滤出指定 Block 的所有 theme，并按字典序排序去重
 */
export function collectThemePathsForHeatmap(params: {
    items: Item[];
    dataSource: ViewInstance;
    sourceBlock: BlockTemplate;
}): string[] {
    const { items, dataSource, sourceBlock } = params;

    // 先按数据源规则过滤
    const filteredItems = filterByRules(items, dataSource.filters || []);

    const themeSet = new Set<string>();

    filteredItems.forEach(item => {
        if (item.categoryKey === sourceBlock.name && item.theme) {
            themeSet.add(item.theme);
        }
    });

    return Array.from(themeSet).sort((a, b) => a.localeCompare(b, 'zh-CN'));
}
```

> 注意：
>
> * 这里 **不再关心 Notice / dataStore / onChange**，只做纯计算。
> * 入参是核心 type：`Item` / `ViewInstance` / `BlockTemplate`，都是 core 层的。

#### 2.2 在 Editor 里改用 core 工具

回到 `features/settings/HeatmapViewEditor.tsx`：

1. 顶部增加：

```ts
import { collectThemePathsForHeatmap } from '@core/utils/heatmap';
```

2. 把原来的 `handleScanThemes` 改成：

```ts
const handleScanThemes = () => {
    if (!module?.dataSourceId) {
        new Notice('请先为此视图选择一个数据源。');
        return;
    }
    if (!config.sourceBlockId) {
        new Notice('请先选择源 Block 模板。');
        return;
    }

    const dataSource = allDataSources.find(ds => ds.id === module.dataSourceId);
    if (!dataSource) {
        new Notice('找不到所选的数据源。');
        return;
    }

    const sourceBlock = allBlocks.find(b => b.id === config.sourceBlockId);
    if (!sourceBlock) {
        new Notice('找不到所选的 Block 模板。');
        return;
    }

    const items = dataStore.queryItems();

    const sortedThemes = collectThemePathsForHeatmap({
        items,
        dataSource,
        sourceBlock,
    });

    onChange({ themePaths: sortedThemes });
    new Notice(`扫描完成！已自动添加 ${sortedThemes.length} 个主题路径（来自分类 "${sourceBlock.name}"）。`);
};
```

> ✅ 这样改完之后：
>
> * **复杂的 items 处理逻辑已经在 core/utils/heatmap.ts**；
> * Editor 只负责：
>
>   * 从 store 拿 dataSource / block / items；
>   * 调用 core 函数；
>   * 用 Notice + onChange 做 UI 反馈。

#### 2.3 后续要共用逻辑时，视图直接用 core 工具

例如将来在 `features/views/HeatmapView.tsx` 里，你如果也需要“根据 filters + block 找所有 themes”，可以直接：

```ts
import { collectThemePathsForHeatmap } from '@core/utils/heatmap';
```

拿到 `items` / `dataSource` / `sourceBlock` 后调用同一个函数，而不是再复制一遍 forEach。

---

## 二、Statistics 视图：共用分类发现逻辑拆到 core

### 步骤 1：把“发现基础分类”的逻辑抽到 core

`features/settings/StatisticsViewEditor.tsx` 里现在有：

```ts
const discoveredCategories = useMemo(() => {
    if (!dataStore) return [];
    const allItems = dataStore.queryItems();
    const categorySet = new Set<string>();
    allItems.forEach(item => {
        const baseCategory = (item.categoryKey || '').split('/')[0];
        if (baseCategory) {
            categorySet.add(baseCategory);
        }
    });
    return Array.from(categorySet).sort((a, b) => a.localeCompare(b, 'zh-CN'));
}, [dataStore]);
```

这些逻辑其实完全可以放到 core，让视图 / 编辑器复用。

1. 打开：`core/utils/dataAggregation.ts`
   在这个文件里已经有各种按日期 / 分类 / 主题的聚合逻辑，是最合适的地方。

2. 在文件里添加一个导出函数，例如放在文件靠前位置：

```ts
import type { Item } from '@/core/types/schema';
// ... 其他已有 import

/** 从 items 中抽取所有一级分类（categoryKey 的第一段）并排序 */
export function discoverBaseCategories(items: Item[]): string[] {
    const categorySet = new Set<string>();
    items.forEach(item => {
        const baseCategory = (item.categoryKey || '').split('/')[0];
        if (baseCategory) {
            categorySet.add(baseCategory);
        }
    });
    return Array.from(categorySet).sort((a, b) => a.localeCompare(b, 'zh-CN'));
}
```

### 步骤 2：Editor 改成使用 core 工具

回到 `features/settings/StatisticsViewEditor.tsx`：

1. 顶部加：

```ts
import { discoverBaseCategories } from '@core/utils/dataAggregation';
```

2. 把 `useMemo` 改成：

```ts
const discoveredCategories = useMemo(() => {
    if (!dataStore) return [];
    const allItems = dataStore.queryItems();
    return discoverBaseCategories(allItems);
}, [dataStore]);
```

> ✅ 之后：
>
> * “如何从 items 里抽一级分类”这件事只定义在 core；
> * 任何别的地方（比如 `StatisticsView.tsx` 里如果也要用）都直接调用 `discoverBaseCategories`。

---

## 三、把这个模式推广到「每个视图」的通用操作清单

现在你有这些视图相关文件：

* 视图：

  * `features/views/BlockView.tsx`
  * `features/views/ExcelView.tsx`
  * `features/views/HeatmapView.tsx`
  * `features/views/StatisticsView.tsx`
  * `features/views/TableView.tsx`
  * `features/views/TimelineView.tsx`
* 编辑器：

  * `features/settings/BlockViewEditor.tsx`
  * `features/settings/ExcelViewEditor.tsx`
  * `features/settings/HeatmapViewEditor.tsx`
  * `features/settings/StatisticsViewEditor.tsx`
  * `features/settings/TableViewEditor.tsx`
  * `features/settings/TimelineViewEditor.tsx`

你可以对“每一个视图类型”按下面模版来改：

---

### 模版 1：默认配置统一进 `core/config/viewConfigs.ts`

对于每个视图（Table / Timeline / Excel / BlockView 等 ）：

1. 在对应的 `*ViewEditor.tsx` 里找到类似：

```ts
export const DEFAULT_CONFIG = { ... };
```

2. 把这段移到 `core/config/viewConfigs.ts`，定义：

```ts
export interface XxxViewConfig { ... }

export const XXX_VIEW_DEFAULT_CONFIG: XxxViewConfig = { ... };
```

3. 在 Editor 里：

```ts
import { XXX_VIEW_DEFAULT_CONFIG } from '@core/config/viewConfigs';

const config = { ...XXX_VIEW_DEFAULT_CONFIG, ...value };
```

4. 为了兼容旧代码，如果有地方还在 `@features/settings/XxxViewEditor` 里 import `DEFAULT_CONFIG`，就在 Editor 里加：

```ts
export { XXX_VIEW_DEFAULT_CONFIG as DEFAULT_CONFIG } from '@core/config/viewConfigs';
```

---

### 模版 2：每个视图的数据处理逻辑统一进 `core/utils/xxx.ts`

对于每个视图，把“纯逻辑”抽掉，步骤完全可以照 Heatmap / Statistics 的做法来：

1. 在 `features/views/XxxView.tsx` 和 `features/settings/XxxViewEditor.tsx` 里找：

   * 大段 `items.forEach(...)`、`reduce(...)`、`Map`、`Set` 之类的运算；
   * `categoryKey` / `date` / `theme` / `rating` 等字段的解析；
   * 多处出现的同一类逻辑（例如“按日期/分类分组”、“统计次数”、“找最近 N 天”等）。

2. 在 `core/utils/` 下新建对应文件，比如：

   * `core/utils/tableView.ts`
   * `core/utils/timeline.ts`
   * `core/utils/blockView.ts`
   * `core/utils/excelView.ts`
   * `core/utils/heatmap.ts`（已建）
   * `core/utils/statistics.ts`（如果需要额外统计逻辑）

3. 把这些纯计算逻辑整理成**纯函数**，只接受参数，不接触 UI / store：

```ts
// 例：TableView 按行列分组
export function buildTableMatrix(items: Item[], rowField: string, colField: string) {
    const matrix: Record<string, Record<string, Item[]>> = {};
    const rowVals = new Set<string>();
    const colVals = new Set<string>();

    // ... 原先的分组逻辑 ...

    return { matrix, rowVals: Array.from(rowVals), colVals: Array.from(colVals) };
}
```

4. 在 View / Editor 里用这些函数替换原来的内联逻辑，例如：

```ts
import { buildTableMatrix } from '@core/utils/tableView';

const { matrix, rowVals, colVals } = buildTableMatrix(items, rowField, colField);
```

---

### 模版 3：保证 core 不依赖 features，只依赖 schema/types 和 utils

写 core 工具函数时遵守两条：

1. **只能依赖 core 层：**

   * `@/core/types/schema`
   * `@core/utils/*`
   * `@core/config/*`

2. 不要在 core 里 import：

   * `features/*`
   * `@/app/AppStore`
   * React/Preact Hook
   * Obsidian UI（`Notice` 等）

UI 相关东西（Notice、Modal、按钮回调）全部留在 `features/views` / `features/settings` 里。

---

## 最后一句话帮你归纳一下

> 你现在可以从 Heatmap 开始，按下面顺序执行：
>
> 1. 把各个视图的 `DEFAULT_CONFIG` 挪到 `core/config/viewConfigs.ts`，在 Editor 里只做引入 + 可选 re-export；
> 2. 每个视图新建一个 `core/utils/xxx.ts`，把所有「遍历 items / 分组 / 聚合 / 提取字段」的逻辑写为纯函数；
> 3. 在 `features/views/*` 和 `features/settings/*ViewEditor.tsx` 里，把原来的计算逻辑删掉，改成调用 core 的纯函数，只保留 UI 和 Store 接线。

如果你愿意，下一步你可以告诉我「先想拆哪个视图（比如 Timeline / Table）」，我可以直接给你对应文件的“改前 / 改后代码片段”，你照抄就行。
